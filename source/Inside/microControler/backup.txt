#define F_CPU 8000000

#include<util/delay.h>
#include<avr/io.h>
#include<avr/interrupt.h>

#include "twislave.h"
#include "timer.h"


/****************************
 *  I2C Register Map
 *----------------------------
 *  0x00 - 0x01 Batterie Voltage (3 Zellen)
 *  0x02 - 0x03 Batterie Voltage (Spannungsteiler 6 Zellen)
 *  0x04 - 0x05 Sonar Back Right
 *  0x06 - 0x07 Sonar Front Right
 *  0x08 - 0x09 Sonar Front
 *  0x0A - 0x0B Sonar Front Left
 *  0x0C - 0x0D Sonar Back Left
 *  0x0E - 0x0F (empty)
 *  0x10 - 0x11 Right Wheel Rotations
 *  0x12 - 0x13 Right Wheel Sensor Resistance
 *  0x14 - 0x15 Left Wheel Rotations
 *  0x16 - 0x17 Left Wheel Sensor Resistance
 ****************************/

#define LOWER_VOLTAGE_BUFFER 0x00
#define LOWER_VOLTAGE_MUX 0b0011

#define HIGHER_VOLTAGE_BUFFER 0x02
#define HIGHER_VOLTAGE_MUX 0b0010

volatile uint8_t rxbuffer[buffer_size];
volatile uint8_t txbuffer[buffer_size];
volatile uint8_t buffer_adr;

void measureADC1();
void measureADC2();

void measureSONAR1();
void measureSONAR2();
void measureSONAR3();
void measureSONAR4();
void measureSONAR5();

void calcRightWheelRotation();
void calcLeftWheelRotation();

void main()
{
        cli();

        init_twi_slave( 0x24 << 1 );

    init_timer_interrupt();



    // Set up ADC converter
        ADMUX |= (0b01 << 6);  //Avcc als referenzwert
    ADCSRA |= 0b000; //0b111; // Setting Prescaler to 128
        ADCSRA |= 1 << 7; // ADEN - Enable

    sei();

        DDRD |= 0b01010101; // Set trigger lines as output
        PORTD |= 0b01010101; //Setze ausgÃ¤nge auf high

        DDRB |= 0b01000000;
        PORTB |= 0b01000000;

        DDRD &= 0b01010101; // Set echo lines as input
        DDRB &= 0b01111111;

    for( int i = 0; i < buffer_size; i++ )
    {
        txbuffer[i] = 0x00;
    }

    char sonar_to_measure = 0;
    char batterie_adc_to_measure = 0;

        while( 1 )
        {
        txbuffer[0x10] = TCNT1;
        txbuffer[0x11] = TCNT1 >> 8;

        _delay_ms(20);



        // Read the wehhel encoders in every round
        /*calcLeftWheelRotation();
        calcRightWheelRotation();

        sonar_to_measure = 0xff;

        // Now measure one Sonar per round
        switch( sonar_to_measure )
        {
        case 0:
                measureSONAR1();
                break;

        case 1:
                measureSONAR2();
                break;

        case 2:
                measureSONAR3();
                break;

        case 3:
                measureSONAR4();
                break;

        case 4:
                measureSONAR5();
                break;

        // Measure one of the Batterie ADC
        case 5:
            if( batterie_adc_to_measure == 0)
            {
                batterie_adc_to_measure = 1;
                measureADC1();
            }
            else
            {
                batterie_adc_to_measure = 0;
                measureADC2();
            }
            break;

        default:
            sonar_to_measure = 0;
            break;
        }

        sonar_to_measure = (sonar_to_measure+1)%6; */


    } // End of while loop
}

// measure front sonar
void measureSONAR1()
{
        PORTB |= 0x40;

        _delay_us( 20 );

        // Beginne Messung mit fallender Flanke
        PORTB &= (0xff^0x40);

        uint16_t high_counter = 0;

        for( uint16_t i = 0 ; i< 20300; i++ )
        {
                // Pin ist High
                if( PINB & 0x80   )
                {
                        high_counter++;
                }

                _delay_us( 10 );
        }

        txbuffer[ 0x04 ] = high_counter & 0xff;
        txbuffer[ 0x05 ] = (high_counter >> 8 ) & 0xff;
}

void measureSONAR2()
{
        PORTD |= 0x40;

        _delay_us( 20 );

        // Beginne Messung mit fallender Flanke
        PORTD &= (0xff^0x40);

        static uint16_t test = 0;

        uint16_t high_counter = 0;

        for( uint16_t i = 0 ; i< 20300; i++ )
        {
                // Pin ist High
                if( PIND & 0x80   )
                {
                        high_counter++;
                }

                _delay_us( 10 );
        }

        txbuffer[ 0x06 ] = high_counter & 0xff;
        txbuffer[ 0x07 ] = (high_counter >> 8 ) & 0xff;
}

void measureSONAR3()
{
        PORTD |= 0x10;

        _delay_us( 20 );

        // Beginne Messung mit fallender Flanke
        PORTD &= (0xff^0x10);

        static uint16_t test = 0;

        uint16_t high_counter = 0;

        for( uint16_t i = 0 ; i< 20300; i++ )
        {
                // Pin ist High
                if( PIND & 0x20   )
                {
                        high_counter++;
                }

                _delay_us( 10 );
        }

        txbuffer[ 0x08 ] = high_counter & 0xff;
        txbuffer[ 0x09 ] = (high_counter >> 8 ) & 0xff;
}

void measureSONAR4()
{
        PORTD |= 0x01;

        _delay_us( 20 );

        // Beginne Messung mit fallender Flanke
        PORTD &= (0xff^0x01);

        static uint16_t test = 0;

        uint16_t high_counter = 0;

        for( uint16_t i = 0 ; i< 20300; i++ )
        {
                // Pin ist High
                if( PIND & 0x2   )
                {
                        high_counter++;
                }

                _delay_us( 10 );
        }

        txbuffer[ 0x0A ] = high_counter & 0xff;
        txbuffer[ 0x0B ] = (high_counter >> 8 ) & 0xff;
}

void measureSONAR5()
{
        PORTD |= 0x04;

        _delay_us( 20 );

        // Beginne Messung mit fallender Flanke
        PORTD &= (0xff^0x04);

        static uint16_t test = 0;

        uint16_t high_counter = 0;

        for( uint16_t i = 0 ; i< 20300; i++ )
        {
                // Pin ist High
                if( PIND & 0x08 )
                {
                        high_counter++;
                }

                _delay_us( 10 );
        }

        txbuffer[ 0x0C ] = high_counter & 0xff;
        txbuffer[ 0x0D ] = (high_counter >> 8 ) & 0xff;
}

void measureADC1()
{
    ADMUX &= 0xf0;
        ADMUX |= LOWER_VOLTAGE_MUX;

        ADCSRA |=  (1<<6); // Enable Conversion

        // Warte bis fertig
        while(ADCSRA & (1<<6) ) {}

        uint16_t result = ADC;

        txbuffer[LOWER_VOLTAGE_BUFFER] = result & 0xff;
        txbuffer[LOWER_VOLTAGE_BUFFER+1] = (result >> 8) & 0xff;
}

void measureADC2()
{
    ADMUX &= 0xf0;
        ADMUX |= HIGHER_VOLTAGE_MUX;

        ADCSRA |=  (1<<6); // Enable Conversion

        // Warte bis fertig
        while(ADCSRA & (1<<6) ) {}

        uint16_t result = ADC;

        txbuffer[HIGHER_VOLTAGE_BUFFER] = result & 0xff;
        txbuffer[HIGHER_VOLTAGE_BUFFER+1] = (result >> 8) & 0xff;
}

void calcRightWheelRotation()
{
    static uint16_t right_rotations = 0;
    static enum{ BLACK, WHITE } act_color = BLACK;

    // Mux to ADC1
    ADMUX &= 0xf0;
    ADMUX |= 0x01;

    ADCSRA |=  (1<<6); // Enable Conversion

    // Warte bis fertig
    while(ADCSRA & (1<<6) ) {}

    uint16_t result = ADC;

    // Store the raw results
    txbuffer[0x12] = result & 0xff;
    txbuffer[0x13] = (result >> 8) & 0xff;

    // calc color
    // changed to white
    if( act_color == BLACK && result <= 0x200)
    {
        act_color = WHITE;
        right_rotations++;

        txbuffer[0x10] = right_rotations & 0xff;
        txbuffer[0x11] = (right_rotations >> 8) & 0xff;
    }

    // changed to black
    else if( act_color == WHITE && result > 0x200 )
    {
        act_color = BLACK;
        right_rotations++;

        txbuffer[0x10] = right_rotations & 0xff;
        txbuffer[0x11] = (right_rotations >> 8) & 0xff;
    }

    // Color didnt change
    else
    {}
}

void calcLeftWheelRotation()
{
    static uint16_t left_rotations = 0;
    static enum{ BLACK, WHITE } act_color = BLACK;


    // Mux to ADC0
    ADMUX &= 0xf0;
    ADMUX |= 0x00;

    ADCSRA |=  (1<<6); // Enable Conversion

    // Warte bis fertig
    while(ADCSRA & (1<<6) ) {}

    uint16_t result = ADC ;

    // Store the raw results
    txbuffer[0x16] = result & 0xff;
    txbuffer[0x17] = (result >> 8) & 0xff;

    // calc color
    // changed to white
    if( act_color == BLACK && result <= 0x200)
    {
        act_color = WHITE;
        left_rotations++;

        txbuffer[0x14] = left_rotations & 0xff;
        txbuffer[0x15] = (left_rotations >> 8) & 0xff;
    }

    // changed to black
    else if( act_color == WHITE && result > 0x200 )
    {
        act_color = BLACK;
        left_rotations++;

        txbuffer[0x14] = left_rotations & 0xff;
        txbuffer[0x15] = (left_rotations >> 8) & 0xff;
    }

    // Color didnt change
    else
    {}
}
